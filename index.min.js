const speedoMeterOptions={angle:0.1,lineWidth:0.7,radiusScale:1,pointer:{length:0.5,strokeWidth:0.05,color:"#000000",},limitMax:true,limitMin:true,colorStart:"#1fffff",colorStop:"#9edf43",strokeColor:"#444444",generateGradient:true,highDpiSupport:true,staticLabels:{font:"15px sans-serif",labels:[0,50,100,150,200,250,300],color:"red",fractionDigits:0,},};const acceleMeterOptions={...speedoMeterOptions,staticLabels:{...speedoMeterOptions.staticLabels,labels:[0,5,10,15,20,25,30],},};const ballOptions={radius:10,color:"yellow",material:"steel",elasticity:0.7,resistence:0.9,accelerationRatio:5,interval:0.02,speed:0,position:{x:0,y:0,},direction:{x:1,y:0,},acceleration:{x:0,y:0,},tanAcceleration:{x:0,y:0,},maxAcceleration:4,maxTanAcceleration:10,tanAccelRate:0,accelRate:0,maxSpeed:200,laps:0,status:"normal",};const carStatus={NORMAL:"normal",REDSPEED:"reduceSpeed",HALFREDSPEED:"halfReduceSpeed",REDACCEL:"reduceAccel",LAP:"lap",UNKNOWN:"unknown",};const Dot=(vec1,vec2)=>{return vec1[0]*vec2[0]+vec1[1]*vec2[1];};const Cross=(vec1,vec2)=>{return vec1[0]*vec2[1]-vec1[1]*vec2[0];};const Rotate=(vec,angle)=>{let newVec=[0,0];newVec[0]=vec[0]*Math.cos(angle)-vec[1]*Math.sin(angle);newVec[1]=vec[0]*Math.sin(angle)+vec[1]*Math.cos(angle);return newVec;};const vecNorm=(vec)=>{return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2));};const TrackList=[{imageUrl:"track1.PNG",name:"INFITI",startPos:{xRatio:0.025,yRatio:0.5},startDirection:{x:0.01,y:1},},{imageUrl:"track2.PNG",name:"OVALLL",startPos:{xRatio:0.5,yRatio:0.9},startDirection:{x:-1,y:0.01},},];const getRGBData=(image,width,height)=>{width=Math.round(width);height=Math.round(height);let canvas=document.createElement("canvas");canvas.width=width;canvas.height=height;canvas.className="Track";let ctx=canvas.getContext("2d");ctx.drawImage(image,0,0,width,height);let data=ctx.getImageData(0,0,width,height).data;data=Array.from(data);const data_array=math.reshape(data,[height,width,4]);return{canvas,data_array};};class Circle{constructor(props){this.state=props;} getCenter=()=>{return{x:this.state.position.x+this.state.radius,y:this.state.position.y+this.state.radius,};};getStatus=()=>{return this.state.status;};getLaps=()=>{return this.state.laps;};getRadius=()=>{return this.state.radius;};getSpeed=()=>{return this.state.speed;};getColor=()=>{return this.state.color;};getAcceleration=()=>{return vecNorm([this.state.acceleration.x,this.state.acceleration.y]);};getTanAcceleration=()=>{return vecNorm([this.state.tanAcceleration.x,this.state.tanAcceleration.y,]);};getValidLap=()=>{return this.state.validLap;};getPosition=()=>{return this.state.position;};getDirection=()=>{return this.state.direction;};changeColor=(color)=>{this.state.color=color;};changeRadius=(radius)=>{this.state.radius=radius;};changeMaterial=(material)=>{this.state.material=material;};changeSpeed=(speed)=>{this.state.speed=speed;};changeDirection=(direction)=>{this.state.direction=direction;};changeAcceleration=(acceleration)=>{this.state.acceleration=acceleration;};changeTanAcceleration=(acceleration)=>{this.state.tanAcceleration=acceleration;};changeAccelRate=(rate)=>{this.state.accelRate=rate;};changeTanAccelRate=(rate)=>{this.state.tanAccelRate=rate;};addLap=(lap)=>{this.state.laps+=lap;};changeStatus=(status)=>{if(status==carStatus.REDSPEED){if(this.state.status==carStatus.REDACCEL){this.state.accelerationRatio*=2;} this.changeSpeed(this.state.speed*0.8);}else if(status==carStatus.HALFREDSPEED){if(this.state.status==carStatus.REDACCEL){this.state.accelerationRatio*=2;} this.changeSpeed(this.state.speed*0.99);}else if(status!=this.state.status){if(this.state.status==carStatus.NORMAL&&status==carStatus.LAP){const trackDir=this.state.track.startDirection;const proj=Dot([trackDir.x,trackDir.y],[this.state.direction.x,this.state.direction.y]);if(proj>0){this.state.validLap=true;this.addLap(1);}else{this.state.validLap=false;this.addLap(-1);}}else if(status==carStatus.REDACCEL){this.state.accelerationRatio/=2;}else if(this.state.status==carStatus.REDACCEL){this.state.accelerationRatio*=2;}} this.state.status=status;};resetAccel=()=>{this.changeAcceleration({x:0,y:0,});this.changeAccelRate(0);};resetTanAccel=()=>{this.changeTanAcceleration({x:0,y:0,});this.changeTanAccelRate(0);};accelerate=(dir)=>{const rate=this.state.accelRate;const direction=this.state.direction;const vector=[direction.x,direction.y];const speed=this.state.speed;const ratio=(this.state.maxSpeed-speed)/this.state.maxSpeed;if(this.getAcceleration()<this.state.maxAcceleration){this.changeAccelRate(rate+1);} this.changeAcceleration({x:dir*rate*ratio*vector[0],y:dir*rate*ratio*vector[1],});};turnLeft=(dir)=>{const rate=this.state.tanAccelRate;const direction=this.state.direction;const vector=[direction.x,direction.y];const speed=this.state.speed;const ratio=speed/this.state.maxSpeed;const newVector=Rotate(vector,Math.PI/2);if(this.getTanAcceleration()<this.state.maxTanAcceleration){this.changeTanAccelRate(rate+1);} this.changeTanAcceleration({x:dir*rate*ratio*newVector[0],y:dir*rate*ratio*newVector[1],});};transmit=()=>{const speed=this.state.speed;const interval=this.state.interval;const dirVector=[this.state.direction.x,this.state.direction.y];const accelVector=[this.state.acceleration.x+this.state.tanAcceleration.x,this.state.acceleration.y+this.state.tanAcceleration.y,];let speedX=speed*dirVector[0];let speedY=speed*dirVector[1];speedX+=accelVector[0]*interval*this.state.accelerationRatio;speedY+=accelVector[1]*interval*this.state.accelerationRatio;const newSpeed=vecNorm([speedX,speedY]);const newDirection=newSpeed==0?this.state.direction:{x:speedX/newSpeed,y:speedY/newSpeed};this.changeSpeed(newSpeed);this.changeDirection(newDirection);};updateBoundary=(multiple,ratio)=>{const{w,h}=getGamePadDim(multiple,ratio);const xl=this.state.position.x;const xh=xl+2*this.state.radius;const yl=this.state.position.y;const yh=yl+2*this.state.radius;let hitStatus={xhitL:false,xhitH:false,yhitL:false,yhitH:false};if(xl<0){hitStatus.xhitL=true;} if(xh>w){hitStatus.xhitH=true;} if(yl<0){hitStatus.yhitL=true;} if(yh>h){hitStatus.yhitH=true;} return hitStatus;};changePosition=(position)=>{const hitStatus=this.updateBoundary(1,0.6);const isNeg=this.state.speed<0;const e=this.state.elasticity;let speedShift=0;if(hitStatus.yhitL){this.state.direction.y=isNeg?-Math.abs(this.state.direction.y):Math.abs(this.state.direction.y);speedShift=this.state.speed*(1-e)*Math.abs(this.state.direction.y);} if(hitStatus.yhitH){this.state.direction.y=isNeg?Math.abs(this.state.direction.y):-Math.abs(this.state.direction.y);speedShift=this.state.speed*(1-e)*Math.abs(this.state.direction.y);} if(hitStatus.xhitL){this.state.direction.x=isNeg?-Math.abs(this.state.direction.x):Math.abs(this.state.direction.x);speedShift=this.state.speed*(1-e)*Math.abs(this.state.direction.x);} if(hitStatus.xhitH){this.state.direction.x=isNeg?Math.abs(this.state.direction.x):-Math.abs(this.state.direction.x);speedShift=this.state.speed*(1-e)*Math.abs(this.state.direction.x);} speedShift+=this.state.speed*(1-this.state.resistence)*Math.abs(this.state.interval);this.state.speed-=speedShift;this.state.position=position;};move=()=>{let newX=this.state.position.x+ this.state.speed*this.state.direction.x*this.state.interval;let newY=this.state.position.y+ this.state.speed*this.state.direction.y*this.state.interval;this.changePosition({x:newX,y:newY});this.transmit();};reset=()=>{this.state.speed=0;this.state.position={x:0,y:0};this.state.direction={x:1,y:0};this.state.acceleration={x:1,y:0};};echoState=()=>{console.log(this.state);};} let globalDataArray=null;const getGamePadDim=(multiple,ratio)=>{let w=window.innerHeight*multiple;let h=w*ratio;return{w,h};};const toggleInstruction=()=>{let instruction=document.getElementById("Modal");if(instruction.style.display=="flex")instruction.style.display="none";else instruction.style.display="flex";};const createBall=(props)=>{let newBall=new Circle(props);let newEle=document.createElement("div");let newFill=document.createElement("img");newFill.src="./car.png";newFill.height=(2*props.radius).toString();newFill.width=(2*props.radius).toString();newEle.className="Ball";newEle.id="ball";newEle.style.position="absolute";applyState(newEle,newBall);let parent=document.getElementsByClassName("GamePad")[0];newEle.appendChild(newFill);parent.appendChild(newEle);return{ele:newEle,ball:newBall,fill:newFill};};const applyState=(element,ballObj)=>{element.style.height=(2*ballObj.getRadius()).toString()+"px";element.style.width=(2*ballObj.getRadius()).toString()+"px";element.style.backgroundColor=ballObj.getColor();element.style.left=ballObj.getPosition().x.toString()+"px";element.style.bottom=ballObj.getPosition().y.toString()+"px";};const createMeter=(min,max,initValue=0,id,options)=>{let target=document.getElementById(id);let gauge=new Gauge(target).setOptions(options);gauge.maxValue=max;gauge.setMinValue(min);gauge.animationSpeed=10;gauge.set(initValue);return gauge;};const setMeters=(realSpeed,realAccele,realTanAccele,speedoMeter,acceleMeter,tanAcceleMeter)=>{let speedReading=document.getElementById("SpeedReading");speedReading.innerHTML=Math.round(realSpeed).toString();let acceleReading=document.getElementById("AcceleReading");acceleReading.innerHTML=Math.round(realAccele).toString();let tanAcceleReading=document.getElementById("TanAcceleReading");tanAcceleReading.innerHTML=Math.round(realTanAccele).toString();speedoMeter.set(realSpeed);acceleMeter.set(realAccele);tanAcceleMeter.set(realTanAccele);};const decideColor=(colorCode)=>{const r=colorCode[0];const g=colorCode[1];const b=colorCode[2];if(r>=211&&g>=211&&b>=211){return"white";}else if(r<=30&&g<=30&&b<=30){return"black";}else if(b-r>30&&b-g>30){return"blue";}else if(r-b>30&&r-g>30){return"red";}else if(g-b>30&&g-r>30){return"green";}else{return"unknown";}};const modifyStatus=(ballObj)=>{if(globalDataArray!=null){const center=ballObj.getCenter();const{w,h}=getGamePadDim(1,0.6);let status="normal";center.x=Math.round(center.x);center.y=Math.floor(h)-Math.round(center.y);if(center.x<0||center.x>Math.floor(w)||center.y<0||center.y>Math.floor(h)){status="outOfBound";}else{const colorCode=globalDataArray[center.y][center.x];const color=decideColor(colorCode);if(color=="white"){status=carStatus.NORMAL;}else if(color=="red"){status=carStatus.REDACCEL;}else if(color=="blue"){status=carStatus.LAP;}else if(color=="green"){status=carStatus.HALFREDSPEED;}else if(color=="black"){status=carStatus.REDSPEED;}else{status=carStatus.UNKNOWN;} ballObj.changeStatus(status);}}};const timeFormat=(time)=>{const intPart=Math.floor(time);const remainPart=Math.round((time%1)*100);const minPart=Math.floor(intPart/60);const secPart=intPart%60;const minString=minPart<10?"0"+minPart.toString():minPart.toString();const secString=secPart<10?"0"+secPart.toString():secPart.toString();const remainString=remainPart<10?"0"+remainPart.toString():remainPart.toString();const timeString=minString+":"+secString+":"+remainString;return timeString;};const setInfo=(laps,time,bestTime)=>{let lapReading=document.getElementById("LapCount");let timeReading=document.getElementById("LapTime");let bestReading=document.getElementById("BestLapTime");lapReading.innerHTML=laps.toString();timeReading.innerHTML=timeFormat(time);bestReading.innerHTML=timeFormat(bestTime);};const rotateImage=(fillImage,ballObj)=>{const direction=ballObj.getDirection();let deg=(Math.atan(direction.y/direction.x)*180)/Math.PI;if(direction.x>0){deg=deg;}else{deg=180+deg;} fillImage.style.transform="rotate("+-deg+"deg)";};const refreshTrack=(index=0)=>{const track=TrackList[index];const{w,h}=getGamePadDim(1,0.6);let gamePad=document.getElementsByClassName("GamePad")[0];const image=document.createElement("img");const trackName=document.getElementById("TrackName");trackName.innerHTML=track.name;image.src=TrackList[index].imageUrl;image.className="RaceTrack";gamePad.innerHTML="";ballOptions.track=track;ballOptions.position={x:w*track.startPos.xRatio,y:h*track.startPos.yRatio,};ballOptions.direction={x:track.startDirection.x,y:track.startDirection.y,};ballOptions.speed=0;ballOptions.laps=0;const{ele,ball,fill}=createBall(ballOptions);image.onload=()=>{let{canvas,data_array}=getRGBData(image,w,h);gamePad.appendChild(canvas);globalDataArray=data_array;};return{ele,ball,fill};};const initGame=()=>{let trackNo=0;let bestTime=0;let currentTime=0;let map={};let{ele,ball,fill}=refreshTrack(trackNo);window.onresize=()=>{bestTime=0;currentTime=0;const val=refreshTrack(trackNo);ele=val.ele;ball=val.ball;fill=val.fill;};const changeTrackBtn=document.getElementById("controlTrack");changeTrackBtn.onclick=()=>{bestTime=0;currentTime=0;if(trackNo+1<TrackList.length){trackNo++;}else{trackNo=0;} const val=refreshTrack(trackNo);ele=val.ele;ball=val.ball;fill=val.fill;};document.onkeydown=document.onkeyup=(e)=>{e=e||event;map[e.key]=e.type=="keydown";};let lock=false;const speedoMeter=createMeter(0,300,0,"Speedometer",speedoMeterOptions);const acceleMeter=createMeter(0,30,0,"Accelemeter",acceleMeterOptions);const tanAcceleMeter=createMeter(0,30,0,"TanAccelemeter",acceleMeterOptions);setInterval(()=>{currentTime+=ballOptions.interval;if(map["w"])ball.accelerate(1);if(map["s"])ball.accelerate(-1);if(map["a"])ball.turnLeft(1);if(map["d"])ball.turnLeft(-1);if(map["r"])ball.reset();if(!map["w"]&&!map["s"])ball.resetAccel();if(!map["a"]&&!map["d"])ball.resetTanAccel();ball.move();const realSpeed=ball.getSpeed();const realAccele=ball.getAcceleration();const realTanAccele=ball.getTanAcceleration();const realLaps=ball.getLaps();const status=ball.getStatus();if(status==carStatus.LAP){if(!lock&&realLaps!=1&&(bestTime==0||currentTime<bestTime)){if(ball.getValidLap())bestTime=currentTime;else bestTime=5999.99;} currentTime=0;lock=true;}else{lock=false;} setMeters(realSpeed,realAccele,realTanAccele,speedoMeter,acceleMeter,tanAcceleMeter);setInfo(realLaps,currentTime,bestTime);modifyStatus(ball);applyState(ele,ball);rotateImage(fill,ball);},1000*ballOptions.interval);};window.onload=()=>{initGame();};